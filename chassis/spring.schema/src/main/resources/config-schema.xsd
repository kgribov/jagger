<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<?xml-stylesheet type="text/xsl" href="xs3p.xsl"?>
<xsd:schema xmlns="http://www.griddynamics.com/schema/jagger"
            xmlns:beans="http://www.springframework.org/schema/beans"
            xmlns:xsd="http://www.w3.org/2001/XMLSchema"
            targetNamespace="http://www.griddynamics.com/schema/jagger"
            elementFormDefault="qualified">
    <xsd:import namespace="http://www.springframework.org/schema/beans"
                schemaLocation="http://www.springframework.org/schema/beans/spring-beans-3.0.xsd"/>

    <!--BASIC TYPES-->

    <xsd:complexType name="identifiedType">
        <xsd:annotation>
            <xsd:documentation>
                Basic type which contains id attribute to identify elements.
            </xsd:documentation>
        </xsd:annotation>
        <xsd:attribute name="id" type="xsd:ID"/>
    </xsd:complexType>

    <xsd:complexType name="identifiedRequiredType">
        <xsd:annotation>
            <xsd:documentation>
                Basic type which contains id attribute to identify elements.
            </xsd:documentation>
        </xsd:annotation>
        <xsd:attribute name="id" type="xsd:ID" use="required"/>
    </xsd:complexType>

    <xsd:complexType name="basicType" abstract="true">
        <xsd:annotation>
            <xsd:documentation>
                Basic type which help you to realize inheritance.
            </xsd:documentation>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="identifiedType">
                <xsd:attribute name="parent" type="xsd:string"/>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="primitiveOrObjectAbstract" abstract="true" mixed="true">
        <xsd:annotation>
            <xsd:documentation>
                A special type of object, which can configure with inner elements and with inner content.
            </xsd:documentation>
        </xsd:annotation>
        <xsd:attribute name="parent" type="xsd:string"/>
        <xsd:attribute name="id" type="xsd:ID"/>
    </xsd:complexType>

    <xsd:complexType name="primitiveAbstract" abstract="true">
        <xsd:annotation>
            <xsd:documentation>
                A basic type for primitive objects.
            </xsd:documentation>
        </xsd:annotation>
        <xsd:simpleContent>
            <xsd:extension base="xsd:string">
            </xsd:extension>
        </xsd:simpleContent>
    </xsd:complexType>

    <xsd:element name="primitive" type="primitiveAbstract"/>

    <xsd:element name="boolean" type="boolean" substitutionGroup="primitive"/>
    <xsd:element name="integer" type="integer" substitutionGroup="primitive"/>
    <xsd:element name="long" type="long" substitutionGroup="primitive"/>
    <xsd:element name="float" type="boolean" substitutionGroup="primitive"/>
    <xsd:element name="double" type="boolean" substitutionGroup="primitive"/>
    <xsd:element name="string" type="string" substitutionGroup="primitive"/>

    <xsd:complexType name="boolean">
        <xsd:simpleContent xml:base="xsd:boolean">
            <xsd:extension base="primitiveAbstract">
            </xsd:extension>
        </xsd:simpleContent>
    </xsd:complexType>

    <xsd:complexType name="integer">
        <xsd:simpleContent xml:base="xsd:integer">
            <xsd:extension base="primitiveAbstract">
            </xsd:extension>
        </xsd:simpleContent>
    </xsd:complexType>

    <xsd:complexType name="long">
        <xsd:simpleContent xml:base="xsd:long">
            <xsd:extension base="primitiveAbstract">
            </xsd:extension>
        </xsd:simpleContent>
    </xsd:complexType>

    <xsd:complexType name="float">
        <xsd:simpleContent xml:base="xsd:float">
            <xsd:extension base="primitiveAbstract">
            </xsd:extension>
        </xsd:simpleContent>
    </xsd:complexType>

    <xsd:complexType name="double">
        <xsd:simpleContent xml:base="xsd:double">
            <xsd:extension base="primitiveAbstract">
            </xsd:extension>
        </xsd:simpleContent>
    </xsd:complexType>

    <xsd:complexType name="string">
        <xsd:simpleContent xml:base="xsd:string">
            <xsd:extension base="primitiveAbstract">
            </xsd:extension>
        </xsd:simpleContent>
    </xsd:complexType>

    <xsd:complexType name="primitiveEntry">
        <xsd:complexContent>
            <xsd:extension base="identifiedType">
                <xsd:choice>
                    <xsd:element ref="primitive"/>
                    <xsd:element name="value" type="primitiveAbstract"/>
                </xsd:choice>
                <xsd:attribute name="key" type="xsd:string" use="required"/>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="primitiveMap">
        <xsd:complexContent>
            <xsd:extension base="basicType">
                <xsd:choice minOccurs="1" maxOccurs="unbounded">
                    <xsd:element name="param" type="primitiveEntry"/>
                </xsd:choice>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <!--CONFIGURATION-->

    <!--configuration-->
    <xsd:element name="configuration" type="configurationType">
        <xsd:annotation>
            <xsd:documentation>
                Configuration is a main element in Jagger. It say Jagger what to do.
                Configuration can be configure by three elements - test-suite, latency-percentiles, report.
                Element test-suite describes what load you would like to execute.
                With element report you can configure how your report will look like.
                Latency-percentiles is an element, which
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>

    <xsd:complexType name="configurationType">
        <xsd:annotation>
            <xsd:documentation>
                Configuration is a main element in Jagger. It say Jagger what to do.
                Configuration can configure by three elements - test-suite, latency-percentiles, report.
                Element test-suite describes what load you would like to execute.
                With element report you can configure how you report will look like.
                Latency-percentiles is an element, which
            </xsd:documentation>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="basicType">
                <xsd:all>
                    <xsd:element name="test-suite" type="testSuiteTypeIn" minOccurs="0" maxOccurs="1"/>
                    <xsd:element name="session-execution-listeners" type="slistenersTypeIn" minOccurs="0" maxOccurs="1"/>
                    <xsd:element name="task-execution-listeners" type="tlistenersTypeIn" minOccurs="0" maxOccurs="1"/>
                    <xsd:element name="latency-percentiles" type="latencyPercentilesTypeIn" minOccurs="0" maxOccurs="1"/>
                    <xsd:element name="report" type="reportType" minOccurs="0" maxOccurs="1"/>
                </xsd:all>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <!--listeners-->

    <xsd:element name="session-execution-listeners" type="slistenersType"/>

    <xsd:element name="task-execution-listeners" type="tlistenersType"/>

    <xsd:element name="latency-percentiles" type="latencyPercentilesType"/>

    <xsd:complexType name="slistenersType">
        <xsd:complexContent>
            <xsd:extension base="basicType">
                <xsd:choice minOccurs="0" maxOccurs="unbounded">
                    <xsd:element name="session-listener" type="slistenersTypeIn"/>
                    <xsd:element ref="beans:bean"/>
                    <xsd:element ref="beans:ref"/>
                </xsd:choice>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="tlistenersType">
        <xsd:complexContent>
            <xsd:extension base="basicType">
                <xsd:choice minOccurs="0" maxOccurs="unbounded">
                    <xsd:element name="task-listener" type="tlistenersTypeIn"/>
                    <xsd:element ref="beans:bean"/>
                    <xsd:element ref="beans:ref"/>
                </xsd:choice>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="slistenersTypeIn">
        <xsd:complexContent>
            <xsd:extension base="slistenersType">
                <xsd:attribute name="ref" type="xsd:string"/>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="tlistenersTypeIn">
        <xsd:complexContent>
            <xsd:extension base="tlistenersType">
                <xsd:attribute name="ref" type="xsd:string"/>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="latencyPercentilesType">
        <xsd:complexContent>
            <xsd:extension base="basicType">
                <xsd:choice>
                    <xsd:element name="percentile" type="xsd:string" minOccurs="1" maxOccurs="unbounded"/>
                </xsd:choice>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="latencyPercentilesTypeIn">
        <xsd:complexContent>
            <xsd:extension base="latencyPercentilesType">
                <xsd:attribute name="ref" type="xsd:string"/>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <!--TASKS-->
    <xsd:element name="processing" type="testSuiteType"/>

    <xsd:element name="test-suite" type="testSuiteType">
        <xsd:annotation>
            <xsd:documentation>
                Test-suite is a list of test-groups. Test-groups will runs in the order that you have.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>

    <xsd:element name="test-group" type="testGroupType">
        <xsd:annotation>
            <xsd:documentation>
                Test-group is a list of tests. All tests will run in parallel mode.
                You can turn on monitoring, if you would like to see monitoring results for this test-group.
                Note : don't forget to set id for this element. Id will be written in report.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>

    <xsd:element name="test" type="testType">
        <xsd:annotation>
            <xsd:documentation>
                Test have attribute testDescription and includes two child elements : load, termination.
                TestDescription describes what targets will be tested and what tool use to test it. Set id of test-description, which you would like to use.
                Element load say how often you would like to load targets.
                With element termination you can configure how long targets will be tested.
                Note : don't forget to set id for this element. Id will be written in report.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>

    <xsd:element name="load" type="loadAbstract">
        <xsd:annotation>
            <xsd:documentation>
                Load is an element, which describes how often you would like to make load.
                You can choose one of load types - load-tps, load-user-groups, load-user-group, load-invocation.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>

    <xsd:element name="termination" type="terminationAbstract">
        <xsd:annotation>
            <xsd:documentation>
                Termination describes how long load will be executed.
                You can choose one of termination types - termination-duration, termination-iterations, termination-background.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>

    <xsd:element name="termination-duration" type="termination-duration" substitutionGroup="termination"/>

    <xsd:element name="termination-iterations" type="termination-iterations" substitutionGroup="termination"/>

    <xsd:element name="termination-background" type="termination-background" substitutionGroup="termination"/>

    <xsd:element name="load-user" type="load-user-group" substitutionGroup="load"/>

    <xsd:element name="load-user-group" type="load-user-group" substitutionGroup="load"/>

    <xsd:element name="load-threads" type="load-threads" substitutionGroup="load"/>

    <xsd:element name="load-invocation" type="load-invocation" substitutionGroup="load"/>

    <xsd:element name="load-tps" type="load-tps" substitutionGroup="load"/>

    <xsd:complexType name="testType">
        <xsd:annotation>
            <xsd:documentation>
                Test have attribute testDescription and includes two child elements : load, termination.
                TestDescription describes what targets will be tested and what tool use to test it. Set id of test-description, which you would like to use.
                Element load say how often you would like to load targets.
                With element termination you can configure how long targets will be tested.
                Note : don't forget to set id for this element. Id will be written in report.
            </xsd:documentation>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="identifiedType">
                <xsd:all>
                    <xsd:element name="load" type="loadAbstract" maxOccurs="1"/>
                    <xsd:element name="termination" type="terminationAbstract" maxOccurs="1"/>
                </xsd:all>
                <xsd:attribute name="testDescription" type="xsd:string" use="required"/>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="loadAbstract" abstract="true">
        <xsd:annotation>
            <xsd:documentation>
                Load is an element, which describes how often you would like to make load.
                You can choose one of load types - load-tps, load-user-groups, load-user-group, load-invocation.
            </xsd:documentation>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="identifiedType">
                <xsd:attribute name="tickInterval" type="xsd:string"/>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="terminationAbstract" abstract="true">
        <xsd:annotation>
            <xsd:documentation>
                Termination describes how long load will be executed.
                You can choose one of termination types - termination-duration, termination-iterations, termination-background.
            </xsd:documentation>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="identifiedType">
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="termination-iterations">
        <xsd:annotation>
            <xsd:documentation>
                This termination strategy is helpful, when you would like to execute an exact number of iterations.
                Attribute 'iterations' say how much iterations you would like to execute.
                With attribute 'maxDuration' you can configure maximum execution time of test. By default it equals 2 hours.
            </xsd:documentation>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="terminationAbstract">
                <xsd:attributeGroup ref="iterationsAttributes"/>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="termination-duration">
        <xsd:annotation>
            <xsd:documentation>
                Use this termination, when you would like to execute your load within a certain time.
            </xsd:documentation>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="terminationAbstract">
                <xsd:attributeGroup ref="durationAttributes"/>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="termination-background">
        <xsd:annotation>
            <xsd:documentation>
                Test with such termination strategy will wait another tests in test-group to be stopped.
            </xsd:documentation>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="terminationAbstract">
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="testGroupType">
        <xsd:annotation>
            <xsd:documentation>
                Test-group is a list of tests. All tests will run in parallel mode.
                You can turn on monitoring, if you would like to see monitoring results for this test-group.
                Note : don't forget to set id for this element. Id will be written in report.
            </xsd:documentation>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="identifiedRequiredType">
                <xsd:choice minOccurs="0" maxOccurs="unbounded">
                    <xsd:element ref="test" maxOccurs="unbounded"/>
                    <xsd:element ref="beans:bean"/>
                    <xsd:element ref="beans:ref"/>
                </xsd:choice>
                <xsd:attribute name="monitoringEnabled" type="xsd:string" default="${chassis.conditions.monitoring.enable}" use="optional"/>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="testGroupTypeIn">
        <xsd:annotation>
            <xsd:documentation>
                Test-group is a list of tests. All tests will run in parallel mode.
                You can turn on monitoring, if you would like to see monitoring results for this test-group.
                Note : don't forget to set id for this element. Id will be written in report.
                You can set a reference to existing test-group with attribute 'ref'.
            </xsd:documentation>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="testGroupType">
                <xsd:attribute name="ref" type="xsd:string"/>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="testSuiteType">
        <xsd:annotation>
            <xsd:documentation>
                Test-suite is a list of test-groups. Test-groups will runs in the order that you have.
            </xsd:documentation>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="identifiedType">
                <xsd:choice minOccurs="0" maxOccurs="unbounded">
                    <xsd:element name="test-group" type="testGroupTypeIn" maxOccurs="unbounded"/>
                    <xsd:element ref="beans:bean"/>
                    <xsd:element ref="beans:ref"/>
                </xsd:choice>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="testSuiteTypeIn">
        <xsd:annotation>
            <xsd:documentation>
                Test-suite is a list of test-groups. Test-groups will runs in the order that you have.
                You can set a reference to existing test-suite with attribute 'ref'.
            </xsd:documentation>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="testSuiteType">
                <xsd:attribute name="ref" type="xsd:string"/>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="load-user-groups">
        <xsd:annotation>
            <xsd:documentation>
                This load is a list of elements user. Every such element imitates a group of threads.
            </xsd:documentation>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="loadAbstract">
                <xsd:choice>
                    <xsd:element name="user" type="userGroupIn" minOccurs="1" maxOccurs="unbounded"/>
                </xsd:choice>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="userGroupIn">
        <xsd:annotation>
            <xsd:documentation>
                This element imitates a group of threads. You can configure a number of threads by attributes.
                count is a max number of threads, that you can use.
                startCount is a start number of threads.
                startIn is a time duration between increase of threads.
                startBy is a number on how much to increase number of threads.
                life describes how long threads will be alive.
            </xsd:documentation>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="loadAbstract">
                <xsd:attributeGroup ref="userAttributes"/>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="load-user-group">
        <xsd:annotation>
            <xsd:documentation>
                This load imitates one user group. See type load-user-groups.
            </xsd:documentation>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="loadAbstract">
                <xsd:attributeGroup ref="userAttributes"/>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="load-threads">
        <xsd:annotation>
            <xsd:documentation>
                This type of load provides an exact count of threads, which will load your targets.
            </xsd:documentation>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="loadAbstract">
                <xsd:attributeGroup ref="virtualUserAttributes"/>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="load-invocation">
        <xsd:annotation>
            <xsd:documentation>
                This type of load provides an exact number of invocations.
                Attribute exactcount says - how much invocations jagger have to execute, attribute threads - how much threads jagger can use. delay is a time(milliseconds) between invocations. By default it equals 0.
            </xsd:documentation>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="loadAbstract">
                <xsd:attributeGroup ref="invocationAttributes"/>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="load-tps">
        <xsd:annotation>
            <xsd:documentation>
                This type of load imitates an exact number of transactions per second.
                By using attribute 'value', you can configure a number of transactions.
                Attribute 'maxThreadNumber' say how much threads you would like to use, to create such tps load. By default it equals 4000.
                Attribute 'warmUpTime' -  time for increase of tps.
            </xsd:documentation>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="loadAbstract">
                <xsd:attributeGroup ref="tpsAttributes"/>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="load-rps">
        <xsd:annotation>
            <xsd:documentation>
                This type of load imitates an exact number of requests per second.
                By using attribute 'value', you can configure a number of requests.
                Attribute 'maxThreadNumber' say how much threads you would like to use, to create such rps load. By default it equals 4000.
                Attribute 'warmUpTime' -  time for increase of rps.
            </xsd:documentation>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="loadAbstract">
                <xsd:attributeGroup ref="tpsAttributes"/>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="load-ref">
        <xsd:annotation>
            <xsd:documentation>
                Set bean of load, which you would like to use.
            </xsd:documentation>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="loadAbstract">
                <xsd:attribute name="ref" type="xsd:string" use="required"/>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:attributeGroup name="userAttributes">
        <xsd:attribute name="count" type="xsd:string" use="required"></xsd:attribute>
        <xsd:attribute name="startCount" type="xsd:string" use="required"></xsd:attribute>
        <xsd:attribute name="startIn" type="xsd:string" use="required"></xsd:attribute>
        <xsd:attribute name="startBy" type="xsd:string" use="required"></xsd:attribute>
        <xsd:attribute name="life" type="xsd:string" use="required"></xsd:attribute>
    </xsd:attributeGroup>

    <xsd:attributeGroup name="virtualUserAttributes">
        <xsd:attribute name="count" type="xsd:integer" use="required"></xsd:attribute>
        <xsd:attribute name="delay" type="xsd:integer" use="optional"></xsd:attribute>
    </xsd:attributeGroup>

    <xsd:attributeGroup name="invocationAttributes">
        <xsd:attribute name="exactcount" type="xsd:integer" use="required"></xsd:attribute>
        <xsd:attribute name="threads" type="xsd:integer" use="required"></xsd:attribute>
        <xsd:attribute name="delay" type="xsd:integer" default="0"></xsd:attribute>
    </xsd:attributeGroup>

    <xsd:attributeGroup name="tpsAttributes">
        <xsd:attribute name="value" type="xsd:integer" use="required"></xsd:attribute>
        <xsd:attribute name="warmUpTime" type="xsd:string" use="optional"></xsd:attribute>
        <xsd:attribute name="maxThreadNumber" type="xsd:integer"/>
    </xsd:attributeGroup>

    <xsd:attributeGroup name="iterationsAttributes">
        <xsd:attribute name="maxDuration" type="xsd:string"></xsd:attribute>
        <xsd:attribute name="iterations" type="xsd:string" use="required"></xsd:attribute>
    </xsd:attributeGroup>

    <xsd:attributeGroup name="durationAttributes">
        <xsd:attribute name="duration" type="xsd:string" use="required"></xsd:attribute>
    </xsd:attributeGroup>

    <!--WORKLOAD-->

    <xsd:element name="test-description" type="testDescriptionType">
        <xsd:annotation>
            <xsd:documentation>
                Test description contains two elements - info-collectors and scenario.
                Info-collectors is a list of collectors. Collector can be as metric element or as validator element.
                In scenario you can describe what targets will be loaded and what tool use to make load.
                You can turn on calibration by adding attribute calibration="true".
                Calibration is a process, when Jagger in a simple(one thread) mode load every target only one time.
                The results, that were calculated in this process, will be a benchmark for comparison with the new iterations.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>

    <xsd:complexType name="testDescriptionType">
        <xsd:annotation>
            <xsd:documentation>
                Test description contains two elements - info-collectors and scenario.
                Info-collectors is a list of collectors. Collector can be as metric element or as validator element.
                In scenario you can describe what targets will be loaded and what tool use to make load.
                You can turn on calibration by adding attribute calibration="true".
                Calibration is a process, when Jagger in a simple(one thread) mode load every target only one time.
                The results, that were calculated in this process, will be a benchmark for comparison with the new iterations.
            </xsd:documentation>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="basicType">
                <xsd:all>
                    <xsd:element name="info-collectors" type="workloadListenersType" minOccurs="0" maxOccurs="1"/>
                    <xsd:element name="scenario" type="scenarioAbstract" minOccurs="0" maxOccurs="1"/>
                </xsd:all>
                <xsd:attribute name="name" type="xsd:string"/>
                <xsd:attribute name="version" type="xsd:integer"/>
                <xsd:attribute name="calibration" type="xsd:boolean" default="false"/>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <!--listeners -->

    <xsd:element name="collector" type="workloadCollectorAbstract"/>

    <!--metrics-->

    <xsd:element name="metric" type="metricAbstract" substitutionGroup="collector">
        <xsd:annotation>
            <xsd:documentation>
                Metric is a kind of collector, which calculate some information from responses. The result is a sum of all calculations.
                Possible types of metric : metric-not-null-response, metric-custom, metric-ref.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>

    <xsd:element name="metric-not-null-response" type="metric-not-null-response" substitutionGroup="metric">
        <xsd:annotation>
            <xsd:documentation>
                This metric calculate not null responses.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>

    <xsd:element name="metric-custom" type="metric-custom" substitutionGroup="metric">
        <xsd:annotation>
            <xsd:documentation>
                You can create your custom metric. Create bean with your own class, which implements interface MetricCalculator.
                Now you can set id of this bean as attribute 'calculator'.
                Set name of metric to see correct it in your report.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>

    <!--validators-->

    <xsd:element name="validator" type="validatorAbstract" substitutionGroup="collector">
        <xsd:annotation>
            <xsd:documentation>
                Validator is a kind of collector, which validate responses. The result is a percent number of valid responses.
                Choose one of validator types - validator-not-null-response, validator-consistency, validator-custom, validator-ref.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>

    <xsd:element name="validator-not-null-response" type="validator-not-null-response" substitutionGroup="validator">
        <xsd:annotation>
            <xsd:documentation>
                This validator validates that response doesn't equals null.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>

    <xsd:element name="validator-consistency" type="validator-consistency" substitutionGroup="validator">
        <xsd:annotation>
            <xsd:documentation>
                Need to add info
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>

    <xsd:element name="validator-custom" type="validator-custom" substitutionGroup="validator">
        <xsd:annotation>
            <xsd:documentation>
                If you would like to use you custom validator - create your own class, which extends class ResponseValidator.
                Now set attribute 'validator' full name of your class.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>

    <xsd:complexType name="workloadListenersType">
        <xsd:complexContent>
            <xsd:extension base="basicType">
                <xsd:choice minOccurs="0" maxOccurs="unbounded">
                    <xsd:element name="metric" type="metricAbstract" maxOccurs="unbounded"/>
                    <xsd:element name="validator" type="validatorAbstract" maxOccurs="unbounded"/>
                </xsd:choice>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="workloadCollectorAbstract" abstract="true">
        <xsd:complexContent>
            <xsd:extension base="basicType">
                <xsd:attribute name="plotData" type="xsd:boolean" default="false"/>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="metricAbstract" abstract="true">
        <xsd:annotation>
            <xsd:documentation>
                Metric is a kind of collector, which calculate some information from responses. The result is a sum of all calculations.
                Possible types of metric : metric-not-null-response, metric-custom, metric-ref.
            </xsd:documentation>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="workloadCollectorAbstract">
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="metric-not-null-response">
        <xsd:annotation>
            <xsd:documentation>
                This metric check, that response is not null.
            </xsd:documentation>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="metricAbstract">
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="metric-custom">
        <xsd:annotation>
            <xsd:documentation>
                You can create your custom metric. Create bean with your own class, which implements interface MetricCalculator.
                Now you can set id of this bean as attribute 'calculator'.
                Set name of metric to see correct report.
            </xsd:documentation>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="metricAbstract">
                <xsd:attribute name="calculator" type="xsd:string" use="required"/>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="metric-ref">
        <xsd:annotation>
            <xsd:documentation>
                Set metric element, that you would like to use.
            </xsd:documentation>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="metricAbstract">
                <xsd:attribute name="ref" type="xsd:string" use="required"/>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>


    <xsd:complexType name="validatorAbstract">
        <xsd:annotation>
            <xsd:documentation>
                Validator is a kind of collector, which validate responses. The result is a percent number of valid responses.
                Choose one of validator types - validator-not-null-response, validator-consistency, validator-custom, validator-ref.
            </xsd:documentation>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="workloadCollectorAbstract">
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="validator-consistency">
        <xsd:annotation>
            <xsd:documentation>
                Need to add info
            </xsd:documentation>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="validatorAbstract">
                <xsd:attribute name="queryEq" type="xsd:string"/>
                <xsd:attribute name="endpointEq" type="xsd:string"/>
                <xsd:attribute name="resultEq" type="xsd:string"/>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="validator-not-null-response">
        <xsd:annotation>
            <xsd:documentation>
                This validator validates that response doesn't equals null.
            </xsd:documentation>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="validatorAbstract">
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="validator-ref">
        <xsd:annotation>
            <xsd:documentation>
                Set validator element, that you would like to use.
            </xsd:documentation>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="validatorAbstract">
                <xsd:attribute name="ref" type="xsd:string" use="required"/>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="validator-custom">
        <xsd:annotation>
            <xsd:documentation>
                If you would like to use you custom validator - create your own class, which extends class ResponseValidator.
                Now set attribute 'validator' full name of your class.
            </xsd:documentation>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="validatorAbstract">
                <xsd:attribute name="validator" type="xsd:string" use="required"/>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <!--possible scenarios-->

    <xsd:element name="scenario" type="scenarioAbstract">
        <xsd:annotation>
            <xsd:documentation>
                Scenario describes what targets will be loaded and what tool use to make load.
                Possible type of scenarios : scenario-query-pool.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>

    <!--<xsd:element name="scenario-http" type="scenario-http" substitutionGroup="scenario"/>-->

    <xsd:element name="scenario-query-pool" type="scenario-query-pool" substitutionGroup="scenario">
        <xsd:annotation>
            <xsd:documentation>
                This scenario contains such elements - invoker, query-provider, endpoint-provider, query-distributor.
                Query-provider generate list of queries. Endpoint-provider generate list of endpoints.
                Query-distributor describes how to distribute queries by endpoints.
                Invoker invokes a query to load endpoint.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>

    <xsd:complexType name="scenarioAbstract" abstract="true">
        <xsd:annotation>
            <xsd:documentation>
                Scenario describes what targets will be loaded and what tool use to make load.
                Possible type of scenarios : scenario-query-pool.
            </xsd:documentation>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="basicType">
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="scenario-ref">
        <xsd:annotation>
            <xsd:documentation>
                Set scenario element, that you would like to use.
                If you would like to create you own scenario, set id of bean, which class implements interface ScenarioFactory.
            </xsd:documentation>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="scenarioAbstract">
                <xsd:attribute name="ref" type="xsd:string" use="required"/>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <!--<xsd:complexType name="scenario-http">-->
        <!--<xsd:complexContent>-->
            <!--<xsd:extension base="scenarioAbstract">-->
                <!--<xsd:all>-->
                    <!--<xsd:element name="endpoint" type="xsd:string" minOccurs="1" maxOccurs="1"/>-->
                    <!--<xsd:element name="http-query" type="query-http" minOccurs="1" maxOccurs="1"/>-->
                <!--</xsd:all>-->
            <!--</xsd:extension>-->
        <!--</xsd:complexContent>-->
    <!--</xsd:complexType>-->

    <xsd:complexType name="scenario-query-pool">
        <xsd:annotation>
            <xsd:documentation>
                This scenario contains such elements - invoker, query-provider, endpoint-provider, query-distributor.
                Query-provider generate list of queries. Endpoint-provider generate list of endpoints.
                Query-distributor describes how to distribute queries by endpoints.
                Invoker invoke a query to load endpoint.
            </xsd:documentation>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="scenarioAbstract">
                <xsd:all>
                    <xsd:element name="invoker" type="invokerAbstract" minOccurs="0" maxOccurs="1"/>
                    <xsd:element name="query-provider" type="queryProviderAbstract" minOccurs="0" maxOccurs="1"/>
                    <xsd:element name="endpoint-provider" type="endpointProviderAbstract" minOccurs="0" maxOccurs="1"/>
                    <xsd:element name="query-distributor" type="queryDistributorAbstract" minOccurs="0" maxOccurs="1"/>
                </xsd:all>
                <xsd:attribute name="calibrationSamplesCount" type="xsd:int" use="optional"/>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <!--possible invokers-->

    <xsd:element name="invoker" type="invokerAbstract">
        <xsd:annotation>
            <xsd:documentation>
                Invoker invokes a query to load endpoint.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>

    <xsd:element name="invoker-http" type="invoker-http" substitutionGroup="invoker">
        <xsd:annotation>
            <xsd:documentation>
                An invoker, that creates HTTP query.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>

    <xsd:element name="invoker-apache-http" type="invoker-apache-http" substitutionGroup="invoker">
        <xsd:annotation>
            <xsd:documentation>
                An invoker, that invoke apache http query (based on 'org.apache.http.client.methods.HttpRequestBase').
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>

    <xsd:element name="invoker-soap" type="invoker-soap" substitutionGroup="invoker">
        <xsd:annotation>
            <xsd:documentation>
                An invoker, that creates SOAP query.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>

    <xsd:element name="invoker-class" type="invoker-class" substitutionGroup="invoker">
        <xsd:annotation>
            <xsd:documentation>
                Set class name of invoker, that you would like to use.
                Note - add an object of this class in context - create bean with this class.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>

    <xsd:complexType name="invokerAbstract" abstract="true">
        <xsd:complexContent>
            <xsd:extension base="basicType">
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="invoker-apache-http">
        <xsd:annotation>
            <xsd:documentation>
                An invoker, that invoke apache http query (based on 'org.apache.http.client.methods.HttpRequestBase').
                org.apache.http.client.methods. HttpGet, HttpPos, HttpPut ...
            </xsd:documentation>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="invokerAbstract">
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="invoker-http">
        <xsd:annotation>
            <xsd:documentation>
                An invoker, that creates HTTP query.
            </xsd:documentation>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="invokerAbstract">
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="invoker-soap">
        <xsd:annotation>
            <xsd:documentation>
                An invoker, that creates SOAP query.
            </xsd:documentation>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="invokerAbstract">
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="invoker-class">
        <xsd:annotation>
            <xsd:documentation>
                Set class name of invoker, that you would like to use.
                Note - add an object of this class in context - create bean with this class.
            </xsd:documentation>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="invokerAbstract">
                <xsd:attribute name="class" type="xsd:string" use="required"/>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <!--queries-->

    <xsd:element name="query-provider" type="queryProviderAbstract">
        <xsd:annotation>
            <xsd:documentation>
                Query provider is a source, where jagger can take queries.
                Possible types of query-provider : query-provider-list, query-provider-ref.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>

    <xsd:element name="query-provider-list" type="query-provider-list" substitutionGroup="query-provider">
        <xsd:annotation>
            <xsd:documentation>
                This element is a list of elements - query.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>

    <xsd:element name="query-provider-file" type="query-provider-file" substitutionGroup="query-provider">
        <xsd:annotation>
            <xsd:documentation>
                This element is a file of line-separated elements - query.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>

    <xsd:element name="query-provider-csv" type="query-provider-csv" substitutionGroup="query-provider">
        <xsd:annotation>
            <xsd:documentation>
                This element is a file of csv elements - query.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>

    <xsd:element name="query" type="queryType">
        <xsd:annotation>
            <xsd:documentation>
                Possible type of query : query-http, query-ref.
                If you don't choose any of type, query will be represented as a string.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>

    <xsd:element name="query-http" type="query-http" substitutionGroup="query">
        <xsd:annotation>
            <xsd:documentation>
                This query implements http query. You can configure it with elements - method-params and client-params.
                Set attribute 'method', it describes what http method you would like to use(for example - GET).
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>

    <xsd:complexType name="queryProviderAbstract" abstract="true">
        <xsd:annotation>
            <xsd:documentation>
                Query provider is a source, where jagger can take queries.
                Possible types of query-provider : query-provider-list, query-provider-ref.
            </xsd:documentation>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="basicType">
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="query-provider-ref">
        <xsd:annotation>
            <xsd:documentation>
                Set reference to your query-provider bean. This bean must implements interface Iterable.
            </xsd:documentation>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="queryProviderAbstract">
                <xsd:attribute name="ref" type="xsd:string" use="required"/>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="query-provider-list">
        <xsd:annotation>
            <xsd:documentation>
                This element is a list of elements - query.
            </xsd:documentation>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="queryProviderAbstract">
                <xsd:choice minOccurs="1" maxOccurs="unbounded">
                    <xsd:element ref="query"/>
                </xsd:choice>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="query-provider-file">
        <xsd:annotation>
            <xsd:documentation>
                This element is a file of line-separated elements - query.
            </xsd:documentation>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="queryProviderAbstract">
                <xsd:choice minOccurs="0" maxOccurs="1">
                    <xsd:element name="object-creator" type="objectCreatorAbstract"/>
                </xsd:choice>
                <xsd:attribute name="delimeter" type="xsd:string" use="optional"/>
                <xsd:attribute name="path" type="xsd:string" use="required"/>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="query-provider-csv">
        <xsd:annotation>
            <xsd:documentation>
                This element is a file of csv elements - query.
            </xsd:documentation>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="queryProviderAbstract">
                <xsd:choice minOccurs="1" maxOccurs="1">
                    <xsd:element name="objectCreator" type="objectCreatorAbstract"/>
                </xsd:choice>
                <xsd:attribute name="path" type="xsd:string" use="required"/>
                <xsd:attribute name="readHeader" type="xsd:boolean" use="optional" default="true"/>
                <xsd:attribute name="strategy" type="csvStrategy" use="optional" default="DEFAULT"/>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:simpleType name="csvStrategy">
        <xsd:restriction base="xsd:string">
            <xsd:enumeration value="DEFAULT"/>
            <xsd:enumeration value="EXCEL"/>
            <xsd:enumeration value="TDF"/>
        </xsd:restriction>
    </xsd:simpleType>

    <xsd:complexType name="objectCreatorAbstract" abstract="true" >
        <xsd:complexContent>
            <xsd:extension base="basicType">
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:element name="object-creator" type="objectCreatorAbstract"/>

    <xsd:element name="object-creator-ref" type="object-creator-ref" substitutionGroup="object-creator"/>

    <xsd:complexType name="object-creator-ref">
        <xsd:complexContent>
            <xsd:extension base="objectCreatorAbstract">
                <xsd:attribute name="ref" type="xsd:string" use="required"/>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="queryType" mixed="true">
        <xsd:annotation>
            <xsd:documentation>
                Possible type of query : query-http, query-ref.
                If you don't choose any of type, query will be represented as a string.
            </xsd:documentation>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="primitiveOrObjectAbstract">
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="query-ref" mixed="true">
        <xsd:annotation>
            <xsd:documentation>
                Set reference to query bean.
            </xsd:documentation>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="queryType">
                <xsd:attribute name="ref" type="xsd:string" use="required"/>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="query-http" mixed="true">
        <xsd:annotation>
            <xsd:documentation>
                This query implements http query. You can configure it with elements - method-params and client-params.
                Set attribute 'method', it describes what http method you would like to use(for example - GET).
            </xsd:documentation>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="queryType">
                <xsd:sequence>
                    <xsd:element name="method-params" type="primitiveMap" minOccurs="0" maxOccurs="1"/>
                    <xsd:element name="client-params" type="primitiveMap" minOccurs="0" maxOccurs="1"/>
                </xsd:sequence>
                <xsd:attribute name="method" type="httpMethodsEnum" default="GET"/>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:simpleType name="httpMethodsEnum">
        <xsd:restriction base="xsd:string">
            <xsd:enumeration value="GET"/>
            <xsd:enumeration value="POST"/>
            <xsd:enumeration value="PUT"/>
            <xsd:enumeration value="DELETE"/>
            <xsd:enumeration value="TRACE"/>
            <xsd:enumeration value="HEAD"/>
            <xsd:enumeration value="OPTIONS"/>
            <xsd:enumeration value="CONNECT"/>
        </xsd:restriction>
    </xsd:simpleType>

    <!--endpoints-->

    <xsd:element name="endpoint-provider" type="endpointProviderAbstract">
        <xsd:annotation>
            <xsd:documentation>
                Endpoint provider is a source, where jagger can take endpoints.
                Possible types of endpoint-provider : endpoint-provider-list, endpoint-provider-ref.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>

    <xsd:element name="endpoint-provider-list" type="endpoint-provider-list" substitutionGroup="endpoint-provider">
        <xsd:annotation>
            <xsd:documentation>
                This element is a list of elements - endpoint.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>

    <xsd:element name="endpoint-provider-file" type="endpoint-provider-file" substitutionGroup="endpoint-provider">
        <xsd:annotation>
            <xsd:documentation>
                This element is a file of line-separated elements - endpoint.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>

    <xsd:element name="endpoint-provider-csv" type="endpoint-provider-csv" substitutionGroup="endpoint-provider">
        <xsd:annotation>
            <xsd:documentation>
                This element is a file of csv elements - endpoint.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>

    <xsd:element name="endpoint" type="endpointType">
        <xsd:annotation>
            <xsd:documentation>
                Possible type of query : endpoint-ref.
                If you don't choose any of type, endpoint will be represented as a string.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>

    <xsd:complexType name="endpointProviderAbstract" abstract="true">
        <xsd:annotation>
            <xsd:documentation>
                Endpoint provider is a source, where jagger can take endpoints.
                Possible types of endpoint-provider : endpoint-provider-list, endpoint-provider-ref.
            </xsd:documentation>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="basicType">
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="endpoint-provider-ref">
        <xsd:annotation>
            <xsd:documentation>
                Set reference to endpoint-provider element or bean. This bean must implements interface Iterable.
            </xsd:documentation>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="endpointProviderAbstract">
                <xsd:attribute name="ref" type="xsd:string" use="required"/>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="endpoint-provider-list">
        <xsd:annotation>
            <xsd:documentation>
                This element is a list of elements - endpoint.
            </xsd:documentation>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="endpointProviderAbstract">
                <xsd:choice minOccurs="1" maxOccurs="unbounded">
                    <xsd:element ref="endpoint"/>
                </xsd:choice>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="endpoint-provider-file">
        <xsd:annotation>
            <xsd:documentation>
                This element is a file of line-separated elements - endpoint.
            </xsd:documentation>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="endpointProviderAbstract">
                <xsd:choice minOccurs="0" maxOccurs="1">
                    <xsd:element name="object-creator" type="objectCreatorAbstract"/>
                </xsd:choice>
                <xsd:attribute name="delimeter" type="xsd:string" use="optional"/>
                <xsd:attribute name="path" type="xsd:string" use="required"/>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="endpoint-provider-csv">
        <xsd:annotation>
            <xsd:documentation>
                This element is a file of csv elements - query.
            </xsd:documentation>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="endpointProviderAbstract">
                <xsd:choice minOccurs="1" maxOccurs="1">
                    <xsd:element name="object-creator" type="objectCreatorAbstract"/>
                </xsd:choice>
                <xsd:attribute name="path" type="xsd:string" use="required"/>
                <xsd:attribute name="readHeader" type="xsd:boolean" use="optional" default="true"/>
                <xsd:attribute name="strategy" type="csvStrategy" use="optional" default="DEFAULT"/>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="endpointType" mixed="true">
        <xsd:annotation>
            <xsd:documentation>
                Possible type of query : endpoint-ref.
                If you don't choose any of type, endpoint will be represented as a string.
            </xsd:documentation>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="primitiveOrObjectAbstract">
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="endpoint-ref" mixed="true">
        <xsd:annotation>
            <xsd:documentation>
                Set reference to endpoint bean.
            </xsd:documentation>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="endpointType">
                <xsd:attribute name="ref" type="xsd:string" use="required"/>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <!--distributors-->

    <xsd:element name="query-distributor" type="queryDistributorAbstract">
        <xsd:annotation>
            <xsd:documentation>
                Query distributor is an object, that provides an algorithm how to distribute queries by endpoints.
                Possible types of query-distributor : query-distributor-round-robin, query-distributor-one-by-one, query-distributor-ref.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>

    <xsd:element name="query-distributor-round-robin" type="query-distributor-round-robin" substitutionGroup="query-distributor">
        <xsd:annotation>
            <xsd:documentation>
                Encapsulates round robin algorithm.
                For input: endpoints [e1, e2] and queries [q1, q2, q3] returns (invoker, query) pairs in following order: (e1, q1), (e2, q2), (e1, q3), (e2, q1), (e1, q2), (e2, q3).
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>

    <xsd:element name="query-distributor-one-by-one" type="query-distributor-one-by-one" substitutionGroup="query-distributor">
        <xsd:annotation>
            <xsd:documentation>
                Schedules queries across endpoints one by one.
                For input: endpoints [e1, e2] and queries [q1, q2, q3] executes actions in following order: (e1, q1), (e2, q1), (e1, q2), (e2, q2), (e1, q3), (e2, q3).
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>

    <xsd:complexType name="queryDistributorAbstract" abstract="true">
        <xsd:annotation>
            <xsd:documentation>
                Query distributor is an object, that provides an algorithm how to distribute queries by endpoints.
                Possible types of query-distributor : query-distributor-round-robin, query-distributor-one-by-one, query-distributor-ref.
            </xsd:documentation>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="basicType">
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="query-distributor-round-robin">
        <xsd:annotation>
            <xsd:documentation>
                Encapsulates round robin algorithm.
                For input: endpoints [e1, e2] and queries [q1, q2, q3] returns (invoker, query) pairs in following order: (e1, q1), (e2, q2), (e1, q3), (e2, q1), (e1, q2), (e2, q3).
            </xsd:documentation>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="queryDistributorAbstract">
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="query-distributor-one-by-one">
        <xsd:annotation>
            <xsd:documentation>
                Schedules queries across endpoints one by one.
                For input: endpoints [e1, e2] and queries [q1, q2, q3] executes actions in following order: (e1, q1), (e2, q1), (e1, q2), (e2, q2), (e1, q3), (e2, q3).
            </xsd:documentation>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="queryDistributorAbstract">
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="query-distributor-ref">
        <xsd:annotation>
            <xsd:documentation>
                Set reference to query-distributor bean. Class of this bean must inheritance class QueryPoolLoadBalancer.
            </xsd:documentation>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="queryDistributorAbstract">
                <xsd:attribute name="ref" type="xsd:string" use="required"/>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <!--REPORTING-->

    <xsd:element name="report" type="reportType">
        <xsd:annotation>
            <xsd:documentation>
                This element can configure your report.
                outputReportLocation say where and how you would like to save your report.
                rootTemplateLocation is a name of jrxml file. Jrxml file is stylesheet file for your report.
                With element session-comparators you can configure session comparison.
            </xsd:documentation>
        </xsd:annotation>
    </xsd:element>

    <xsd:complexType name="reportType">
        <xsd:annotation>
            <xsd:documentation>
                This element can configure your report.
                outputReportLocation say where and how you would like to save your report.
                rootTemplateLocation is a name of jrxml file. Jrxml file is stylesheet file for your report.
                With element session-comparators you can configure session comparison.
            </xsd:documentation>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="identifiedType">
                <xsd:all>
                    <xsd:element name="extensions" type="extensionsType" minOccurs="0"/>
                    <xsd:element name="session-comparators" type="sessionComparatorsType" minOccurs="0"/>
                </xsd:all>
                <xsd:attributeGroup ref="reportTypeAttribute"/>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:attributeGroup name="reportTypeAttribute">
        <xsd:attribute name="rootTemplateLocation" type="xsd:string"/>
        <xsd:attribute name="outputReportLocation" type="xsd:string"/>
    </xsd:attributeGroup>

    <xsd:complexType name="extensionsType">
        <xsd:complexContent>
            <xsd:extension base="identifiedType">
                <xsd:choice minOccurs="0" maxOccurs="unbounded">
                    <xsd:element name="extension" type="extensionType"></xsd:element>
                </xsd:choice>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="extensionType">
        <xsd:complexContent>
            <xsd:extension base="identifiedType">
                <xsd:choice minOccurs="0" maxOccurs="1">
                    <xsd:element ref="beans:ref"/>
                </xsd:choice>
                <xsd:attributeGroup ref="extensionAttribute"/>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:attributeGroup name="extensionAttribute">
        <xsd:attribute name="ref" type="xsd:string" use="optional"/>
    </xsd:attributeGroup>

    <xsd:complexType name="sessionComparatorsType">
        <xsd:annotation>
            <xsd:documentation>
                This element is a list of monitoring and workload comparators.
                By adding attribute 'baselineId' you can add a comparison between your current session and baseline session.
            </xsd:documentation>
        </xsd:annotation>
        <xsd:complexContent>
            <xsd:extension base="identifiedType">
                <xsd:choice minOccurs="0" maxOccurs="unbounded">
                    <xsd:element name="comparator-monitoring" type="comparator-monitoring"/>
                    <xsd:element name="comparator-workload" type="comparator-workload"/>
                </xsd:choice>
                <xsd:attributeGroup ref="sessionComparatorsAttribute"/>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:element name="comparator" type="comparatorAbstract"/>

    <xsd:element name="comparator-monitoring" type="comparator-monitoring" substitutionGroup="comparator"/>

    <xsd:element name="comparator-workload" type="comparator-workload" substitutionGroup="comparator"/>

    <xsd:element name="comparator-ref" type="comparator-ref" substitutionGroup="comparator"/>

    <xsd:element name="decision-maker" type="decisionMakerAbstract"/>

    <!--unsupported yet-->
    <!--<xsd:element name="decision-maker-throughput" type="decision-maker-throughput" substitutionGroup="decision-maker"/>-->

    <!--<xsd:element name="decision-maker-stddev" type="decision-maker-stddev" substitutionGroup="decision-maker"/>-->

    <!--<xsd:element name="decision-maker-ref" type="decision-maker-ref" substitutionGroup="decision-maker"/>-->

    <xsd:complexType name="comparatorAbstract" abstract="true">
        <xsd:complexContent>
            <xsd:extension base="basicType">
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="decisionMakerAbstract" abstract="true">
        <xsd:complexContent>
            <xsd:extension base="basicType"/>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="decisionMakerMonitoringAbstract" abstract="true">
        <xsd:complexContent>
            <xsd:extension base="decisionMakerAbstract"/>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="decisionMakerWorkloadAbstract" abstract="true">
        <xsd:complexContent>
            <xsd:extension base="decisionMakerAbstract"/>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="comparator-monitoring">
        <xsd:complexContent>
            <xsd:extension base="comparatorAbstract">
                <xsd:choice minOccurs="1" maxOccurs="1">
                    <xsd:element name="decision-maker" type="decisionMakerMonitoringAbstract"/>
                </xsd:choice>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="comparator-workload">
        <xsd:complexContent>
            <xsd:extension base="comparatorAbstract">
                <xsd:choice minOccurs="1" maxOccurs="1">
                    <xsd:element name="decision-maker" type="decisionMakerWorkloadAbstract"/>
                </xsd:choice>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="comparator-ref">
        <xsd:complexContent>
            <xsd:extension base="comparatorAbstract">
                <xsd:attribute name="ref" type="xsd:string" use="required"/>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>
    
    <xsd:complexType name="decision-maker-workload-throughput">
        <xsd:complexContent>
            <xsd:extension base="decisionMakerWorkloadAbstract">
                <xsd:attribute name="fatalDeviationThreshold" type="xsd:float" use="required"/>
                <xsd:attribute name="warningDeviationThreshold" type="xsd:float" use="required"/>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="decision-maker-monitoring-stddev">
        <xsd:complexContent>
            <xsd:extension base="decisionMakerMonitoringAbstract">
                <xsd:attribute name="fatalDeviationThreshold" type="xsd:float" use="required"/>
                <xsd:attribute name="warningDeviationThreshold" type="xsd:float" use="required"/>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="decision-maker-monitoring-ref">
        <xsd:complexContent>
            <xsd:extension base="decisionMakerMonitoringAbstract">
                <xsd:attribute name="ref" type="xsd:string" use="required"/>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:complexType name="decision-maker-workload-ref">
        <xsd:complexContent>
            <xsd:extension base="decisionMakerWorkloadAbstract">
                <xsd:attribute name="ref" type="xsd:string" use="required"/>
            </xsd:extension>
        </xsd:complexContent>
    </xsd:complexType>

    <xsd:attributeGroup name="sessionComparatorsAttribute">
        <xsd:attribute name="baselineId" type="xsd:integer" use="optional"/>
        <xsd:attribute name="strategy" type="strategyType" use="optional"/>
    </xsd:attributeGroup>

    <xsd:simpleType name="strategyType">
        <xsd:restriction base="xsd:string">
            <xsd:enumeration value="worstCase"/>
        </xsd:restriction>
    </xsd:simpleType>

</xsd:schema>
